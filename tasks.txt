Тестовое задание для разработчика

1. Есть таблица платежей пользователей:

CREATE TABLE payments (
`id` INT AUTO_INCREMENT PRIMARY KEY NOT NULL,
`student_id` INT NOT NULL,
`datetime` DATETIME NOT NULL,
`amount` FLOAT DEFAULT 0,
INDEX `student_id` (`student_id`)
);

Необходимо составить запрос, который находит пользователя, чья сумма платежей находится на втором месте после максимальной.


2. Есть две таблицы. Первая содержит основные данные по студентам:

CREATE TABLE student (
`id` INT AUTO_INCREMENT PRIMARY KEY NOT NULL,
`name` VARCHAR(20) NOT NULL,
`surname` VARCHAR(20) DEFAULT '' NOT NULL,
`gender` ENUM('male', 'female', 'unknown') DEFAULT 'unknown',
INDEX `gender` (`gender`)
);

Вторая содержит историю статусов студентов, где последний по хронологии статус является текущим:

CREATE TABLE student_status (
`id` INT AUTO_INCREMENT PRIMARY KEY NOT NULL,
`student_id` INT NOT NULL,
`status` ENUM('new', 'studying', 'vacation', 'testing', 'lost') DEFAULT 'new' NOT NULL,
`datetime` DATETIME NOT NULL,
INDEX `student_id` (`student_id`),
INDEX `datetime` (`datetime`)
);


Необходимо показать имена и фамилии всех студентов, чей пол до сих не известен (gender = 'unknown') и они сейчас находятся на каникулах (status = ‘vacation’).



3. Используя три предыдущие таблицы, найти имена и фамилии всех студентов, которые заплатили не больше трех раз и перестали учиться (status = ‘lost’). Нулевые платежи (amount = 0) не учитывать.


И еще одна задача

В одном файле хранятся ID пользователей и время их заходов на сайт за 5 лет существования сайта в произвольном порядке. Известно, что существует порядка миллиона пользователей, четверть из которых были активными. Активные пользователи в среднем по 100 раз в день заходили на какую-либо страницу сайта.

Необходимо описать в понятной форме наиболее оптимальный алгоритм создания нового файла, в котором записи из первого файла будут отсортированы по поряду возрастания ID, а для одинаковых ID по хронологии. (Можно написать небольшую программу на PHP, но не обязательно)

	Например, если в исходном файле:
	1234567890 2013-03-08 12:26:09
	0987654321 2013-03-09 09:23:17
	1234567890 2014-01-01 00:00:34
	0087645544 2015-02-03 17:45:01
0087645544 2015-01-03 11:05:06

	В результирующем должно быть:
0087645544 2015-01-03 11:05:06
0087645544 2015-01-03 17:45:01
0987654321 2013-03-09 09:23:17
1234567890 2013-03-08 12:26:09
1234567890 2014-01-01 00:00:34

